
1- code API needed and executable
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

bioperl-live
ensembl
ensembl-compara

executables
~~~~~~~~~~~
blastall
	using /usr/local/ensembl/bin/blastall

mcl (source can be obtained from http://micans.org/mcl/src/)
	using /nfs/acari/abel/bin/mcxdeblast
	using /nfs/acari/abel/bin/mcxassemble
	using /nfs/acari/abel/bin/mcx
	using /nfs/acari/abel/bin/mcl

2- Choose a working directory with enough disk space
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The family pipeline takes several GB of space (5BG should be sufficient). (df -k)

mkdir /lustre/work1/ensembl/abel/families/family_45
cd /lustre/work1/ensembl/abel/families/family_45
mkdir tmp fasta blast_in blast_out blast_raw mcl muscle clustalw_mpi

3- Loading in and dumping from compara the peptides
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The loading of ensembl peptides/genes and uniprot is now done as a commun trunk with the gene homology pipeline.
The loading process will identify redundant protein using a MySQL index trick and assign to them the same 
sequence_id. Very clever indeed!

Before loading, make sure that in each core db:
a) stable ids are in (look in tables 'exon_stable_id', 'translation_stable_id', 'transcript_stable_id' 
   and 'gene_stable_id')
b) species data in 'meta' table up to date
c) check the gene type e.g. pseudogene or RNA that you don't want to load and update the filter out condition if necessary

NB: need to add something here on how to load or a reference to homology documentation

The dumping is done with ensembl-compara/scripts/pipeline/comparaDumpAllPeptides.pl script.
Don't use -noX or nosplit, use the default setting. The dumping process will dump only one version of each sequence,
so no redundancy is expected in the fasta file.

cd fasta

~/src/ensembl_main/ensembl-compara/scripts/pipeline/comparaDumpAllPeptides.pl -conf your-compara-hive.conf --noredundancy -fasta metazoa_45.pep > metazoa_45.pep.err 2>&1 &

or if you don't have the hive conf file

~/src/ensembl_main/ensembl-compara/scripts/pipeline/comparaDumpAllPeptides.pl --dbhost compara2 --dbport 3306 --dbuser ensro --dbname avilella_compara_homology_45 --noredundancy --fasta metazoa_45.pep > metazoa_45.pep.err 2>&1 &

4- Format file for blast
   ~~~~~~~~~~~~~~~~~~~~~

fastaindex metazoa_45.pep metazoa_45.index
formatdb -p T -l metazoa_45.pep.formatdb.log -i metazoa_45.pep

check metazoa_45.pep.formatdb.log if it is ok delete it

rm -f metazoa_45.pep.formatdb.log

Create the index file for future run of mcl

awk 'BEGIN {idx=0} {print idx,$1;idx++}' metazoa_45.index > metazoa_45.tab

5- Prepare files to run blastp
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~

cd ../blast_in

 Distribute peptide ids in several files. Each of them will contain 100 ids,
 and would correspond to one blastp job.

~/src/ensembl_main/ensembl-compara/scripts/family/SplitPeptides.pl -maxids 250 ../fasta/metazoa_45.index

  The created files are named: PeptideSet.1, PeptideSet.2, ..., PeptideSet.n
  so that they are suitable for LSF job array creation. 
 

6- Run blastp with in a LSF jobs array
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For inof on jobs array, see
http://www.sanger.ac.uk/campus/IT/ISG/lsf/job-arrays.shtml

NB: not done yet, think about putting out the SEG filter in blastp as we do for homologous genepairs, not sure
that is a good idea. Replace SEG by CAST filtering.

 The script used to run individual blastp is
 ensembl-compara/scripts/family/LaunchBlast.pl

 At the beginning of the script, you may need to update few lines that specifie the path
 for the executable to be used

my $blast_executable
my $fastafetch_executable
my $blast_parser_executable


ls|wc -l
      5573

 will tell you how many jobs have to be run. Just have a try with one to make sure everything is ok.

 It is better to place the output files in a different directory to reduce the burden on the filesystem.
 (The fewer files per directory the better).

echo '/nfs/acari/abel/src/ensembl_main/ensembl-compara/scripts/family/LaunchBlast.pl -idqy PeptideSet.${LSB_JOBINDEX} -fastadb /lustre/work1/ensembl/abel/families/family_45/fasta/metazoa_45.pep -fastaindex /lustre/work1/ensembl/abel/families/family_45/fasta/metazoa_45.index -tab /lustre/work1/ensembl/abel/families/family_45/fasta/metazoa_45.tab -dir /lustre/work1/ensembl/abel/families/family_45/blast_raw/' | bsub -q normal -JFamilyBlastp"[1]" -o ../blast_out/PeptideSet.%I.out

 Check that the BLASTMAT points to /usr/local/ensembl/data/blastmat

 When it is complete, you should get 2 new files

../blast_out/PeptideSet.1.out
../blast_raw/PeptideSet.1.raw.gz

 The first is the STDOUT from LSF. The latter is the blastp output parsed (and zipped)
 in the suitable format needed for the following steps.

 To check if the job finished properly

cd ../blast_out
ls |while read i;do echo -n $i" ";awk '/^Subject/ {printf $NF" "} /^Job was executed/ {print;exit}' $i;done|awk '{print $2}'|sort |uniq -c

 That gives you the number of jobs "Done" and "Exited" if any.

 Then run the whole lot of jobs

cd ../blast_in
echo '/nfs/acari/abel/src/ensembl_main/ensembl-compara/scripts/family/LaunchBlast.pl -idqy PeptideSet.${LSB_JOBINDEX} -fastadb /lustre/work1/ensembl/abel/families/family_45/fasta/metazoa_45.pep -fastaindex /lustre/work1/ensembl/abel/families/family_45/fasta/metazoa_45.index -tab /lustre/work1/ensembl/abel/families/family_45/fasta/metazoa_45.tab -dir /lustre/work1/ensembl/abel/families/family_45/blast_raw/' | bsub -q normal -JFamilyBlastp"[2-5573]" -o ../blast_out/PeptideSet.%I.out

 Rerun the failed jobs in ../blast_out.

cd ../blast_out

ls |while read i;do echo -n $i" ";awk '/^Subject/ {printf $NF" "} /^Job was executed/ {print;exit}' $i;done > ../job_status

grep Exited job_status|sed "s/\./ /g"|awk '{print $2}'|sort -n > job_status.ids

awk 'BEGIN {s=0;e=0;i=0} i==15 {print;i=0} s==0 {s=$1;e=$1;next} $1==e+1 {e=$1;next} $1>e+1 && e==s {printf s",";s=$1;e=$1;i++;next} $1>e+1 && e!=s {printf s"-"e",";s=$1;e=$1;i++;next} END {print s"-"e}' job_status.ids > job_status.ids.collapse

grep Exited job_status |awk '{print $1}'|while read i;do del blast_out/$i;done

cat job_status.ids.collapse|while read i;do echo "echo '/nfs/acari/abel/src/ensembl_main/ensembl-compara/scripts/family/LaunchBlast.pl -idqy PeptideSet.\${LSB_JOBINDEX} -fastadb /lustre/work1/ensembl/abel/families/family_45/fasta/metazoa_45.pep -fastaindex /lustre/work1/ensembl/abel/families/family_45/fasta/metazoa_45.index -tab /lustre/work1/ensembl/abel/families/family_45/fasta/metazoa_45.tab -dir /lustre/work1/ensembl/abel/families/family_45/blast_raw/' | bsub -q normal -JFamilyBlastp\"["$i"]\" -o ../blast_out/PeptideSet.%I.out";echo;done > blast_in/rebsub

Then move to blast_in and resubmit the failed jobs

cd blast_in

bash rebsub

8- Build the matrix needed by mcl and check it for symmetry
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

cd ../blast_raw

ls|xargs gunzip -c > ../mcl/family_45.raw

cd ../mcl

 create asymlink to ../fasta/metazoa_45.tab

ln -s ../fasta/metazoa_45.tab family_45.tab

 create a family_45.hdr header file,
 The dimensions should be the number of peptides. That can be obtained by

wc -l family_45.tab

cat > family_45.hdr
(mclheader
mcltype matrix
dimensions 1392888x1392888
)

~/src/ensembl_main/ensembl-compara/scripts/family/mcxassemble.sh family_45

 This takes about 30 min and will generate a family_45.bin matrix file.

We don't need the raw file anymore and as it takes quite a lot of space, delete it.

rm family_45.raw

9- Run mcl
   ~~~~~~~

This step uses turing which has 192Gb of memory :))) and 16 CPUs. As mcl can be multi-threaded, it is very useful.

bsub -C0 -R 'select[ncpus>=8 && mem>10000 && type==LINUX64] rusage[mem=10000] span[hosts=1]' -q hugemem -n 8 -f "family_45.bin > /tmp/family_45.bin" -f "family_45.mcl < /tmp/family_45.mcl" -o mcl.out /nfs/acari/abel/bin/arch-ia64/mcl /tmp/family_45.bin -I 2.1 -t 8 -P 10000 -S 1000 -R 1260 -pct 90 -o /tmp/family_45.mcl

NB: when ever you have finished running mcl (maybe with different parameters), don't forget 
to delete /tmp/family_45.* from aristotle /tmp (a shell script having the flavour of 
mcxassemble.sh or mcx.sh could do it automatically...not very useful though if several mcl run have to be tested)

To save space,

gzip family_45.mcl.gz

10- Load into compara database
    ~~~~~~~~~~~~~~~~~~~~~~~~~

You'll need a compara database set up, with genome_db, taxon, and method_link tables prefilled.

This takes around an hour, and you can not do anything else before the loading is completed.

nohup ~/src/ensembl_main/ensembl-compara/scripts/family/parse_mcl.pl --dbname compara45 --reg_conf reg_conf.pl family_45.tab family_45.mcl > family_45.description 2> family_45.description.err &

Your reg_conf.pl should be something like

use strict;
use Bio::EnsEMBL::Utils::ConfigRegistry;
use Bio::EnsEMBL::Compara::DBSQL::DBAdaptor;

new Bio::EnsEMBL::Compara::DBSQL::DBAdaptor(-host => 'compara2',
                                            -user => 'xxxxx',
                                            -pass => 'xxxxxx',
                                            -port => 3306,
                                            -species => 'compara45',
                                            -dbname => 'avilella_compara_homology_45');
1;



11- Run muscle or clustalw over all the families
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!!!Step 13 should be run also at the same time. It is not dependant on multiple alignments.

cd ../muscle
 
 Just create the number of directory needed by 10000 families and only for those with 2 or more members.
No need to run clustalw on 1 sequence. Let's say that we have 112482 families and only 41136 families
have 2 or more peptide members

mkdir 41136 40000 35000 30000 25000 20000 15000 10000 5000 500
cd 41136
 
Submit jobs for family_id from 40001 to 41136

echo '/nfs/acari/abel/src/ensembl_main/ensembl-compara/scripts/family/LaunchMuscleOnFamilies.pl -host compara2 -port 3306 -dbname avilella_compara_homology_45 -dbuser ensadmin -dbpass ensembl -family_id ${LSB_JOBINDEX}  -store' | bsub -q small -JFamilyMucsle"[40001-41136]" -o %I.out

The same kind of script but running CLUSTALW also exists, ensembl-compara/scripts/family/LaunchMuscleOnFamilies.pl

echo '/nfs/acari/abel/src/ensembl_main/ensembl-compara/scripts/family/LaunchClustalwOnFamilies.pl -host compara2 -port 3306 -dbname avilella_compara_homology_45 -dbuser ensadmin -dbpass xxxx -family_id ${LSB_JOBINDEX} -store' | bsub -q small -JFamilyClustalw"[20001-27152]" -o %I.out

Somtimes in muscle the memory needed is high so you can resubmit failed jobs with -R ressource requirement.

echo '/nfs/acari/abel/src/ensembl_main/ensembl-compara/scripts/family/LaunchMuscleOnFamilies.pl -host compara2 -port 3306 -dbname avilella_compara_homology_45 -dbuser ensadmin -dbpass ensembl -family_id ${LSB_JOBINDEX}  -store' | bsub -q bigmem -R 'select[mem>8000] rusage[mem=9000]' -JFamilyMucsle"[20001-27152]" -o %I.out

If even like that muscle does not run properly, add the -fast option to LaunchMuscleOnFamilies.pl script.

echo '/nfs/acari/abel/src/ensembl_main/ensembl-compara/scripts/family/LaunchMuscleOnFamilies.pl -host compara2 -port 3306 -dbname avilella_compara_homology_45 -dbuser ensadmin -dbpass ensembl -family_id ${LSB_JOBINDEX} -fast -store' | bsub -q bigmem -R 'select[mem>8000] rusage[mem=9000]' -JFamilyMucsle"[20001-27152]" -o %I.out

And if then again it does not work, run clustalw_mpi (see below).

NB: For very small families or singletons, the -q small is the right queue to use, as jobs will be extremely quick. For largest families, let's say from family_id 1 to 500 however (where number of members are often > 150), jobs can be longer, and so the -q normal should be used instead of -q small

then the same things 
cd ../20000 for family_id from 10001 to 20000
cd ../10000 for family_id from 1 to 10000

clustalw_mpi
============

In cases of big families that did not finish with muscle or single-cpu clustalw, you can start clustal_mpi runs while letting
their muscle/single-cpu clustalw jobs running.
mpi_clustalw is a parallelized version of clustalw (that is installed on bc nodes).
As the mpi version is working is rsh command, you want to make sure that you have a ~/.rhosts that contains at least this

+@bc_hosts

and have particular read/write access 

chmod go-rwx ~/.rhosts

So now what to do e.g. for family_id=1

cd ../clustalw_mpi

mysql -h compara2 -P3306 -N -u ensro -e "select m.stable_id from member m, family_member fm where m.member_id=fm.member_id and fm.family_id=1" avilella_compara_homology_45 > 1.ids

fastafetch /lustre/work1/ensembl/abel/families/family_45/fasta/metazoa_45.pep /lustre/work1/ensembl/abel/families/family_45/fasta/metazoa_45.index -F true 1.ids > 1.ids.pep

bsub  -o 1.out -n10 -R"linux span[ptile=2]" ~/src/ensembl_main/ensembl-compara/scripts/family/run_clustalw_mpi.sh 1.ids.pep

NB: span[ptile=2] tells NFS to use 2CPU's per machine 
-n10 tells NFS that you will use 10 CPUs. There is no clear algorithm to choose the right number of CPUs to be used depending on the number of sequences. The more sequences you have the less efficient the mpi implementation is. Guy Coates did some testing

9658 seq 10 CPUs ~14hr
9658 seq 16 CPUs ~13hr
So no much gain from 10 to 16.
1690 seq 10 CPUs ~10min
1690 seq 16 CPUs ~7min

For the largest families we released, I've got that
7015 seq 10 CPUs ~11 hours
4736 seq 10 CPUs  ~5 hours

So as a rule of the thumb, I will recommend
10 CPUs when >=5000 sequences
20 CPUs when <=5000 sequences

Never use over 20 CPUs.

If everything worked fine, you should get 3 additional files, 1.out (the busb output) and 
1.ids.dnd, 1.ids.pep.clw, the clustalw outputs.

To Load the clustalw alignment, first check that the  muscle/single-cpu clustal job did not finish properly (if so
you're done with this family), if not bkill it before loading.
/nfs/acari/abel/src/ensembl_main/ensembl-compara/scripts/family/LaunchClustalwOnFamilies.pl -host compara2 -port 3306 -dbname avilella_compara_homology_45 -dbuser ensadmin -dbpass xxxx -family_id 1 -clustal_file 1.ids.pep.clw -store > 1.ids.pep.clw.load 2>&1 &

12- Insert the redundant proteins in the compara db
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

cd ../fasta

First, set all singletons cigar_line to the length(m.sequence) + "M", because some singletons will disappear with the addition of redundant sequences.

mysql -h compara2 -u ensro -P3306 -N -e "select family_id,count(*) as count from family_member group by family_id having count=1" avilella_compara_homology_45 | awk '{print "select family_id, length(s.sequence) from member m,family_member fm, sequence s where fm.member_id=m.member_id and fm.family_id="$1" and s.sequence_id = m.sequence_id;"}'|mysql -h compara2 -u ensro -P3306 -N avilella_compara_homology_45 |awk '{print "update family_member set cigar_line=\""$2"M\" where family_id="$1";"}'|sort -u > update_singletons_cigar_line.sql

mysql -h compara2 -u ensadmin -pxxxx -P3306 avilella_compara_homology_45 < update_singletons_cigar_line.sql

~/src/ensembl_main/ensembl-compara/scripts/family/InsertRedundantPeptidesAndGenesInFamilies.pl --reg_conf reg_conf.pl --dbname compara45 > Redundancy_and_Genes_load.err 2>&1 &

IMPORTANT: add healthcheck about NULL cigar_line
select m.source_name,count(*) from family_member fm, member m where fm.member_id=m.member_id and fm.cigar_line="NULL" group by m.source_name;

This should return count 0;

select fm.family_id,count(*) from family_member fm, member m where fm.member_id=m.member_id and fm.cigar_line is NULL and m.source_name!='ENSEMBLGENE' group by fm.family_id;

This should only list the families for which multiple alignment could not be run.

13- Generates the family descriptions
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    This part really sucks and need a profound rethinking to get the description more clean and consistant.

       ensembl-compara/scritps/family/consensifier.pl 
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       consensifier.pl -d "Uniprot/SWISSPROT" family_45.description > family_45.description.SWISSPROT-consensus 2> family_45.description.SWISSPROT-consensus.err
       consensifier.pl -d "Uniprot/SPTREMBL" family_45.description > family_45.description.SPTREMBL-consensus 2> family_45.description.SPTREMBL-consensus.err
       This step takes approx 2 hours total

       ensembl-compara/scripts/family/assemble-consensus.pl
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       assemble-consensus.pl family_45.description family_45.description.SWISSPROT-consensus family_45.description.SPTREMBL-consensus  > family_45.description-consensus 2> family_45.description-consensus.err


update the family description in ensembl_family_45 with the data in family_45.description-consensus using ensembl-compara/scripts/family/LoadDescriptionInFamily.pl 
Use the same reg_cong.pl as in step 11

LoadDescriptionInFamily.pl --reg_conf reg_conf.pl --dbname compara45 family_45.description-consensus


