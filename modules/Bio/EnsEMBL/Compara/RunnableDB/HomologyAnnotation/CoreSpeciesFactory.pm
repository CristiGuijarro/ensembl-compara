=head1 LICENSE

Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
Copyright [2016-2020] EMBL-European Bioinformatics Institute

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

=cut

=pod

=head1 NAME

Bio::EnsEMBL::Compara::RunnableDB::HomologyAnnotation::CoreSpeciesFactory

=head1 DESCRIPTION

Wrapper around Production's SpeciesFactory to filter the species output for
rapid release. Filtered by:
    1) Not in main EnsEMBL release
    2) Not a reference species
    3) Does not currently have an existing per-species compara_db (coming soon)
    4) If it does have a per-species compara_db, it is >1 year old (coming soon)

=cut

package Bio::EnsEMBL::Compara::RunnableDB::HomologyAnnotation::CoreSpeciesFactory;

use warnings;
use strict;
use Bio::EnsEMBL::Registry;
use Bio::EnsEMBL::Compara::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Compara::Utils::FlatFile qw(map_row_to_header);
use Bio::EnsEMBL::Hive::Utils ('go_figure_dbc');
use Bio::EnsEMBL::Utils::SqlHelper;
use Data::Dumper;

use base ('Bio::EnsEMBL::Compara::RunnableDB::BaseRunnable');

sub write_output {
    my $self = shift;

    my @new_species      = @{ $self->_get_metadata_genomes };

    foreach my $species ( @new_species ) {
        my (@species_parts) = split /_/, $species;
        pop @species_parts if $species_parts[-1] =~ /gca/;
        $species = join('_', @species_parts);
        # if gdb is returned from ref_db skip genome
        next if scalar @{ $self->_check_if_reference($species) } > 0;

        $self->dataflow_output_id( { 'species' => $species }, 1 );
    }
}

# Internal method to run the genome reporting script to return only the new genomes according to release
sub _get_metadata_genomes {
    my $self = shift;

    my $metadata_dbc   = go_figure_dbc( $self->param_required('rr_meta_db') );
    my $meta_host      = $self->param_required('meta_host');
    my $dump_path      = $self->param_required('dump_path');
    my $metadata_name  = $metadata_dbc->dbname;
    my $report_genomes = $self->param('report_genomes_exe');

    # this is the rapid release number
    my $rr = _get_curr_rr_release($self);

    my $meta_options = "\$($meta_host details script) --dbname $metadata_name --release $rr --eg_first 1 --dump_path $dump_path";

    my $cmd = "perl $report_genomes $meta_options";
    $self->run_command($cmd);

    my @new_species_list;
    # script produces a per-division file
    my @new_genome_files = glob($dump_path . "/*-new_genomes.txt");
    foreach my $file ( @new_genome_files ) {
        my $line_count = `cat $file | wc -l`;
        next if $line_count <= 1;
        push @new_species_list, _parse_new_genome_file($file);
    }

    return \@new_species_list;
}

# Internal method to find the current rapid release number
sub _get_curr_rr_release {
    my $self = shift;

    my $metadata_dbc = go_figure_dbc( $self->param_required('rr_meta_db') );
    my $helper       = $metadata_dbc->sql_helper;

    my $sql = 'SELECT MAX(ensembl_genomes_version) from data_release where is_current = 1';
    # should only return one result, as there is only one current at a time
    my $rr  = $helper->execute_single_result(-SQL => $sql);

    return $rr;
}

# Internal method to parse the report file generated by report_genomes_exe
sub _parse_new_genome_file {
    my $file = shift;

    open ( my $f, "<", $file ) or die "Cannot open report for new species $!";

    my $header = <$f>;

    $header =~ s/^\#//;

    my @species_names;

    while (<$f>) {
        # header line is commented in output
        next if $_ =~ /^\#name/;
        # the strain column can be blank, leading to mismatch of column numbers
        $_ = $_ . 'NULL' if $_ !~ /[a-z]$/;
        my $row = map_row_to_header( $_, $header );
        # only interested in the genome name at the moment
        push @species_names, $row->{name};
    }

    close ($f);

    return @species_names;
}

# Internal method returns undef is genome is not present in reference database
sub _check_if_reference {
    my ($self, $name) = @_;

    my $reference_db  = $self->param_required('rr_ref_db');
    my $reference_dba = Bio::EnsEMBL::Compara::DBSQL::DBAdaptor->go_figure_compara_dba($reference_db);
    return $reference_dba->get_GenomeDBAdaptor->fetch_all_by_name($name);
}

# FIXME: Search all servers in registry containing compara_dbs to check for existing genome instance.
# Return undef if no compara_db or compara_db older than one year
#sub _check_no_recent_compara_db {
#    my $self = shift;
#}

1;
