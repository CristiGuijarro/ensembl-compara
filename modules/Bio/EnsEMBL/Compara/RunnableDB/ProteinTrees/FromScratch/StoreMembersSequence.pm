
=pod 

=head1 NAME

Bio::EnsEMBL::Compara::RunnableDB::LoadOneGenomeDB

=head1 DESCRIPTION

This Runnable loads one entry into 'genome_db' table and passes on the genome_db_id.

The format of the input_id follows the format of a Perl hash reference.
Examples:
    { 'species_name' => 'Homo sapiens', 'assembly_name' => 'GRCh37' }
    { 'species_name' => 'Mus musculus' }

supported keys:
    'locator'       => <string>
        one of the ways to specify the connection parameters to the core database (overrides 'species_name' and 'assembly_name')

    'registry_dbs'  => <list_of_dbconn_hashes>
        another, simple way to specify the genome_db (and let the registry search across multiple mysql instances to do the rest)
    'species_name'  => <string>
        mandatory, but what would you expect?

    'first_found'   => <0|1>
        optional, defaults to 0.
        Defines whether we emulate (to a certain extent) the behaviour of load_registry_from_multiple_dbs
        or try the last one that still fits (this would allow to try ens-staging[12] *first*, and only then check if ens-livemirror has is a suitable copy).

    'assembly_name' => <string>
        optional: in most cases it should be possible to find the species just by using 'species_name'

    'genome_db_id'  => <integer>
        optional, in case you want to specify it (otherwise it will be generated by the adaptor when storing)

    'pseudo_stableID_prefix' => <string>
        optional?, see 'GenomeLoadMembers.pm', 'GenomeLoadReuseMembers.pm', 'GeneStoreNCMembers.pm', 'GenomePrepareNCMembers.pm'

    'ensembl_genomes' => <0|1>
        optional, sets the preferential order of precedence of species_name sources, depending on whether the module is run by EG or Compara

=cut

package Bio::EnsEMBL::Compara::RunnableDB::ProteinTrees::FromScratch::StoreMembersSequence;

use strict;
use warnings;

use Bio::Perl;
use Bio::EnsEMBL::Registry;
use Bio::EnsEMBL::Compara::GenomeDB;
use Bio::EnsEMBL::Compara::Member;
use Bio::EnsEMBL::Compara::Subset;

use Data::Dumper;

use base ('Bio::EnsEMBL::Compara::RunnableDB::BaseRunnable');


sub fetch_input {
	my $self = shift @_;

	# Adaptors
	my $compara_dba = $self->compara_dba();
	$self->param('member_adaptor', $compara_dba->get_MemberAdaptor());
      $self->param('sequence_adaptor', $compara_dba->get_SequenceAdaptor());

	$self->param('genome_db_id', $compara_dba->get_GenomeDBAdaptor->fetch_by_taxon_id($self->param('ncbi_taxon_id'))->dbID );

	$self->param('pepSubset', Bio::EnsEMBL::Compara::Subset->new(-name => ("gdb:".($self->param('genome_db_id'))." ".($self->param('species_name')).' translations')));
	$self->param('geneSubset', Bio::EnsEMBL::Compara::Subset->new(-name => ("gdb:".($self->param('genome_db_id'))." ".($self->param('species_name')).' genes')));

	$self->param('subset_adaptor', $compara_dba->get_SubsetAdaptor());
	$self->param('subset_adaptor')->store($self->param('pepSubset'));
	$self->param('subset_adaptor')->store($self->param('geneSubset'));

}

sub run {
	my $self = shift @_;

	my $genome_db_id = $self->param('genome_db_id');
	my $member_adaptor = $self->param('member_adaptor');

      print "\treading from ".$self->param('protein_file')." and ".$self->param('cds_file')."\n" if $self->debug;
      # load peptides
	my @allseq = read_all_sequences($self->param('protein_file'));
	print scalar(@allseq), " sequences read in ", $self->param('protein_file'), " (taxon_id: ", $self->param('ncbi_taxon_id'), " taxon_name: ", $self->param('species_name'), ")\n" if ($self->debug);
	# load transcripts
	my $allseq_cds = read_all_sequences_hash($self->param('cds_file'));
	print keys(%$allseq_cds), " sequences read in ", $self->param('cds_file'), " (taxon_id: ", $self->param('ncbi_taxon_id'), " taxon_name: ", $self->param('species_name'), ")\n" if ($self->debug);

	my $count = 0;
	foreach my $sequence (@allseq) {
		
		$count++;

		my @t = split(":", $sequence->id);
		
		print "sequence $count: name ", $sequence->id, "\n" if ($self->debug > 1);
		print "sequence $count: description ", $sequence->desc, "\n" if ($self->debug > 1);
		print "sequence $count: length ", $sequence->length, "\n" if ($self->debug > 1);

		my $gene_member = Bio::EnsEMBL::Compara::Member->new();
		$gene_member->stable_id(sprintf("GENE%06d%06d", $self->param('ncbi_taxon_id'), $count));
		$gene_member->display_label($t[1]);
		$gene_member->source_name("ENSEMBLGENE");
		$gene_member->taxon_id($self->param('ncbi_taxon_id'));
		$gene_member->description($sequence->id." ".$sequence->desc);
		$gene_member->genome_db_id($genome_db_id);
		$member_adaptor->store($gene_member);
		$self->param('geneSubset')->add_member($gene_member);

		my $pep_member = Bio::EnsEMBL::Compara::Member->new();
		$pep_member->stable_id(sprintf("PEPT%06d%06d", $self->param('ncbi_taxon_id'), $count));
		$pep_member->display_label($t[1]);
		$pep_member->source_name("ENSEMBLPEP");
		$pep_member->taxon_id($self->param('ncbi_taxon_id'));
		$pep_member->description($sequence->id." ".$sequence->desc);
		$pep_member->genome_db_id($genome_db_id);
		my $seq = $sequence->seq;
		$seq =~ s/O/X/g;
		$pep_member->sequence($seq);
		$member_adaptor->store($pep_member);
		$self->param('pepSubset')->add_member($pep_member);

		$member_adaptor->store_gene_peptide_link($gene_member->dbID, $pep_member->dbID);

            my $sequence_cds = $allseq_cds->{$sequence->id};
            if ((defined $self->param('cds_file')) and (not exists $allseq_cds->{$sequence->id})) {
                die "Could not retrieve CDS object for ".$sequence->id."\n";    
            }

            $pep_member->sequence_cds( $sequence_cds->seq );
            $self->param('sequence_adaptor')->store_sequence_cds($pep_member);

      };

	print $self->param('geneSubset')->count(), " genes and ", $self->param('pepSubset')->count(), " peptides in subsets\n" if ($self->debug);
}

sub write_output {      # dataflow

	my $self = shift;

	$self->dataflow_output_id( { 'genome_db_id' => $self->param('genome_db_id'), 'species_name' => $self->param('species_name') } , 1);
}

##########################################
#
# internal methods
#
##########################################

sub read_all_sequences_hash{
    my $input_file = shift;
    my %sequence2hash = ();
    return \%sequence2hash if not defined $input_file;

    my $in_file  = Bio::SeqIO->new(-file => $input_file , '-format' => 'Fasta');
    while ( my $seq = $in_file->next_seq() ) {
        $sequence2hash{$seq->id} = $seq;
    }

    if(!keys(%sequence2hash)){
        die "Could not read fasta sequences from $input_file\n";
    }
    print "\tFound ".keys(%sequence2hash)." sequences\n";
    return \%sequence2hash;
}

1;

